
import pygame
import sys
import random
import time
WindowSizeX=1200 #размер окна со складом на экране в пикселях. При изменении этого параметра, размеры клеток и вагонеток на экране скорректируются автоматически.
WindowSizeY=675  #то же самое произойдёт при изменении длины или количества полок.

LenShelving=10 #длина одного стеллажа (ячеек)
HeightShelving=1 #высота одного стеллажа (количество ярусов)
LenStorage=3 #длина склада (количество стеллажей)
WidthStorage=3 #ширина склада (количество стеллажей)
KolVag=1 #количество вагонеток на территории склада
inputX=34  #input - точка погрузки товаров на тележки и выгрузки с них
inputY=6
MaxSizeInput=100 #максимальное количество предметов, которые могут находиться в очереди на поступление на склад
MaxX=(LenShelving+1)*LenStorage+1 #размер склада по X
MaxY=(WidthStorage*3)+1  #размер склада по Y
#Поскольку в условии сказано, что площадь склада максимально экономится,
#я предположил, что каждый стеллаж состоит
#из двух рядов полок, на которых независимо может хранится товар.
#Соответственно к каждому товару можно получить доступ только с одной стороны
#Именно такая схема применяется практически на всех существующих складах подобного типа.
'''
горизонтально длина (тут 3)
-------------------
-#####-#####-#####-
-#####-#####-#####-
------------------- Вертикально
-#####-#####-#####- Ширина (тут 4)
-#####-#####-#####-
-------------------
-#####-#####-#####-
-#####-#####-#####-
-------------------
-#####-#####-#####-
-#####-#####-#####-
-------------------
'''

#Цвета на схеме
ColFon=(128, 255, 200)   #цвет фона
ColPol=(128, 0, 200)     #цвет пола
ColStel=(0, 128, 64)     #цвет стеллажей
ColAgent = (128,128,128) #цвет вагонеток
ColTov = (175, 107, 23)  #цвет товаров (им помечаются полные полки и полные вагонетки)
GGG=0
#цвета рамок вагонеток. Что бы они отличались. Вагонетка обозначается большим кружком. Её целевая точка - маленьким кружком того же цвета.
Colors=[(10,10,10),(255,0,0),(0,255,0),(0,0,255),(0,255,255),(255,255,0),(255,0,255),(255,255,255)] 

Zabir=set()  #список товаров, которые нужно забрать со склада и отвезти на пункт выдачи. 


RazKl=min((WindowSizeX//MaxX),(WindowSizeY//MaxY)) #сколько пикселей можно отдать под одну клетку на экране
pygame.init()
screen = pygame.display.set_mode((WindowSizeX, WindowSizeY)) #размеры окна приложения
KolOb=0 #количество доступных мест на складе
Mas=[] #массив доступных полок
MasV=[] #массив доступных вагонеток
MasRast=[] #массив ячеек хранения, упорядоченный по расстоянию до точки входа-выхода.
Block=False
#Данные о полках для хранения
class Slot(object):
    #хранит информацию об одной полке. X Y - координаты полки. Xpos,Ypos - клетка, рядом с полкой, с которой вагонетка может забрать предмет. H-номер яруса. IDshelf - уникальный ID этой ячейки.
    def __init__(self,X ,Y ,Xpos ,Ypos ,H , IDshelf):
        """Constructor"""
        self.X = X
        self.Y = Y
        self.Xpos = Xpos
        self.Ypos = Ypos
        self.H = H
        self.IDshelf = IDshelf #ID этой полки
        self.IDcargo = 0 #товар, лежащий сейчас на полке. Если равен 0, полка пустая.
        self.time = 0 #время хранения товара на поле
        #манхэттенское расстояние до точки выдачи. Основываясь на нём, в самые дальние ячейки будут помещаться предметы на длительное хранение.
        self.dist = abs(inputX-X)+abs(inputY-Y)
    def SetID(self,IDcargo): #кладёт на полку товар. Если IDcargo=0 снимает текущий товар с полки.
        self.IDcargo=IDcargo
 

class Agent(object):
    #Информация о координатах вагонетки X Y
    def __init__(self, X, Y, ID):
        """Constructor"""
        self.ID= ID #ID вагонетки
        self.X = X  #координаты вагонетки
        self.Y = Y
        self.pointX = 0  #текущая цель (точка, в которую нужно приехать, а не книжная полка рядом с ней)
        self.pointY = 0
        self.IDcargo = 0  # ID груза. Если 0 - вагонетка пустая.
        self.IDshelf = 0  # ID первой целевой полки.     Если mode=1 вагонетка возьмёт предмет с первой полки и перевезёт на вторую.
        self.IDshelf2 = 0 # ID второй целевой полки.     Если mode=2 вагонетка отвезёт предмет на вторую полку и оставит там.
        self.mode = 0 #Режим вагонетки. 0 - не имеет цели. 1 - едет за предметом. 2 - везёт предмет.
        self.Nap = 'null' #Направление. Принимает значения D U R L.
        self.time = 0 #время хранения на складе предмета, лежащего на тележке
        self.prior = 0 #приоритет тележки. При встрече двух тележек дорогу уступает та, у которой приоритет ниже. (999 - высокий приоритет, 1 - низкий приоритет)
        # Для приоритета на первом месте цель поездки. Тележка, доставляющая товар со склада на выдачу, имеет приоритет выше, чем тележка, отвозящая товар на склад.
        # Потому что склад подождать может. А клиент врядли. На третьем месте перемещение товаров по складу. А самый низкий приоритет у тележки, не имеющей в данный момент цели.
        # Если цель одинаковая, приоритет зависит от наполнения тележки.
        # Полная тележка имеет приоритет выше, чем пустая. Во-первых потому, что в реальности полная тележка едет медленее и уступить будет проще пустой.
        # А во-вторых потому, что при максимальной нагрузке на склад статистически тележка чаще бывает полной, чем пустой и
        # приоритет полным тележкам даст незначительный прирост в скорости работы.
        # В случае, если у тележек одна цель и одно наполнение приоритет определяется по ID товара в тележке или на целевой полке (если тележка пустая).
        # При необходимости это можно будет использовать, давая самым важным товарам маленький ID, а менее важным - большой. 
        # Так же все эти приоритеты можно менять вручную по необходимости.
        
    def TestPosition(self): #возвращает 0, если вагонетка на перекрёстке. -1 если на вертикальной дороге. 1 если на горизонтальной.
        #ищем полки на четырёх соседних клетках
        A=(FindSlot(self.X+1,self.Y)==-1)
        B=(FindSlot(self.X-1,self.Y)==-1)
        C=(FindSlot(self.X,self.Y+1)==-1)
        D=(FindSlot(self.X,self.Y-1)==-1)
        if A and B and C and D: #если рядом нет полок, это перекрёсток
            return(0) 
        if not(A) or not(B): #если полка справа или слева - вертикальная дорога
            return(-1)
        if not(C) or not(D): #если полка сверху или снизу - горизонтальная дорога
            return(1)
    
    def NewPoint(self,IDcargo,IDshelf): #выдаёт вагонетке новую цель - товар и полку. Вагонетка найдёт на складе или на выдаче товар, указаный в IDcargo,
                                        #приедет на соседнюю с полкой клетку, погрузит его и отвезёт на полку, указаную в IDshelf
                                        #Если на складе и на выдаче нет товара с этим ID вагонетка сообщит об этом и не будет ничего делать.
        T=FindID(IDcargo) #ищем товар на складе
        if T==-1:
            print('Товар не найден')
            return('Товар не найден')
        else:
            self.mode=1 #включаем режим езды за предметом
            self.IDshelf=Mas[T].IDshelf #ID полки, с которой нужно забрать предмет
            self.IDshelf2=IDshelf       #ID полки, на которую нужно положить предмет
            self.pointX=Mas[T].Xpos #записываем в переменные целевой точки клетку рядом с полкой, на которой лежит предмет, который нужно переместить.
            self.pointY=Mas[T].Ypos

    def TestNap(self,Nap): #возвращает 1 если направление движения доступно. 0 если там вагонетка с более низким приоритетом. -1 если в той клетке вагонетка с более высоким приоритетом или стена.
        Gx=self.X #точка, куда попадёт вагонетка после хода
        Gy=self.Y
        if Nap=='R':
            Gx=self.X+1
        if Nap=='L':
            Gx=self.X-1        
        if Nap=='U':
            Gy=self.Y-1
        if Nap=='D':
            Gy=self.Y+1   
        for i in range(KolVag):
            if (MasV[i].X==Gx) and (MasV[i].Y==Gy): #если в целевой клетке есть другая вагонетка, сравниваем приоритеты
                if MasV[i].prior<self.prior:
                    return(0)
                else:
                    return(-1)
        if (Gx<0) or (Gx>=MaxX) or (Gy<0) or (Gy>=MaxY): #если направление заблокировано стеной
            return(-1)
        return(1) #если преград не найдено, возвращаем 1

    
    def drive(self): #вагонетка перемещается к цели, если ей ничего не мешает.
        #алгоритм следующий - если вагонентка на вертикальной или горизонтальной дороге - она движится к целевой клетке. (если на пути нет другой вагонетки)
        #если вагонетка на перекрёстке то доступны два пути (ещё два будут отдалять от цели). Допустим, по X расстояние до цели n1, а по Y - n2.
        #Тогда с вероятностью n1/(n1+n2) вагонетка поедет по координате Y и с вероятностью  n2/(n1+n2) по X. Исключение - если вагонетка и цель находятся на одной прямой.
        #Таким образом разные вагонетки будет избегать одинаковых маршрутов.
        #Если по X нужно проехать много, а по Y мало, то вагонетка скорее всего продпочтёт Y. Если бы вагонетка сокращала
        #сперва расстояние X это приводило бы к тому, что все вагонетки выбирали бы примерно один и тот же маршрут - диагональный.
        #Из-за этого на центральных дорогах были бы пробки, а дороги возле стен были бы пустыми. 
        #А при моей схеме загруженность всех дорог будет приблизительно одинаковой.
        #При этом общая длина пути не изменится и всегда будет равна манхэттенскому расстоянию
        #Если встречаются две вагонетки, та, которая имеет меньший приоритет, начинает ехать в обратную сторону вплоть до перекрёстка.
        Dor=self.TestPosition() #на какой дороге находится вагонетка
        Dx=self.pointX-self.X #расстояние до цели по X и Y
        Dy=self.pointY-self.Y
        global GGG
        Nap='null' #стоим на месте
        #выбираем направление по X или Y
        if Dor==1: #горизонтальная дорога
            Nap='X'
        if Dor==-1: #вертикальная дорога
            Nap='Y'
        if Dor==0: #перекрёсток
            self.Nap='null' #очищаем приоритетное напраление, так как оно действует только до перекрёстка
            if Dx==0: #если на одном уровне по X с целью
                Nap='Y'
            if Dy==0: #если на одном уровне по Y с целью
                Nap='X'                
            if (Dx==0) and (Dy==0):
                Nap='null'
            if Dx*Dy!=0: #если ни X ни Y ещё не достигнуты, выбираем уравнение согласно пропорции
                G=abs(Dx)+abs(Dy) #манхэттенское расстояние
                if random.randint(1,G)>abs(Dy):
                    #если true, значит вагонетка едет по оси Y
                    Nap='Y'               
                else:
                    Nap='X'
                if Dy<=3:
                    Nap='X'
                if Dx<=LenShelving: #если до цели совсем немного, используем оптимальный маршрут
                    Nap='Y'
                    
        #уточняем направление до конкретной стороны
        if (Nap=='X') and (self.Nap=='null'):
            if Dx>0:
                Nap='R' #едем направо
            if Dx<0:
                Nap='L' #едем налево
            if Dx==0: #если нужно обогнуть шкаф, обходим его кратчайшим путём.
                if self.X%(LenShelving+1)<(LenShelving/2):
                    Nap='L'
                    self.Nap='L'
                else:
                    Nap='R'
                    self.Nap='R'
        if Nap=='Y':
            if Dy<0:
                Nap='U' #едем вверх
            if Dy>0:
                Nap='D' #едем вниз
            if Dy==0:
                if self.Y%(3)<(2):
                    Nap='U'
                    self.Nap='U'
                else:
                    Nap='D'
                    self.Nap='D'                
        if (self.X==self.pointX) and (self.Y==self.pointY): #если вагонетка добралась до цели, никуда больше не едем.
            Nap='null'
            self.Nap='null'
        #ищем другую вагонетку на пути. Если она есть и между ней и этой вагонеткой нет ни одного перекрёстка, сравниваем приоритеты. Вагонетка с приоритетем проезжает.
        KK=self.TestNap(Nap)

        if KK==2: #если у целевой вагонетки приоритет ниже нашего, просто ждём, пока она уедет.
            Nap='null'
            self.Nap=Nap
        if KK<1:
            if Dor!=0: #если стоим не на перекрёстке, уезжаем назад
                if Nap=='R':
                    self.Nap='L'
                    Nap='L'
                else:
                    if Nap=='L':
                        self.Nap='R'
                        Nap='R'
                if Nap=='U':
                    self.Nap='D'
                    Nap='D'
                else:
                    if Nap=='D':
                        self.Nap='U'
                        Nap='U'
            if Dor==0: #если стоим на перекрёстке уезжаем в другом направлении.
                alf='RLDU'
                self.Nap='null'
                g=alf[random.randint(0,3)]
                while g==Nap:
                    g=alf[random.randint(0,3)]

        if self.Nap!='null': #если присутствует приоритетное направление, следуем ему
            Nap=self.Nap

        #дополнительно убеждаемся, что на пути нет другой вагонетки (мы ведь сменили направление)
        if self.TestNap(Nap)!=1:
            Nap=='null' #если вагонетка заперта со всех сторон, стоим и ждём, пока дорога освободится
            self.Nap='null'  
        if GGG>5:
            GGG=0
            if Nap=='R':
                Nap='L'
            else:
                if Nap=='L':
                    Nap='R'
            if Nap=='U':
                Nap='D'
            else:
                if Nap=='D':
                    Nap='U'
                
        #собствено двигаемся, если направление движения не равно null        
        if Nap=='R':
            self.X+=1
        if Nap=='L':
            self.X-=1        
        if Nap=='U':
            self.Y-=1
        if Nap=='D':
            self.Y+=1
        
        for i in range(KolVag): #при возникновении проблем пропускаем ход на всякий случай
            for r in range(KolVag):
                if (MasV[i].X==MasV[r].X) and (MasV[i].Y==MasV[r].Y) and (i!=r):
                    if Nap=='R':
                        self.X-=1
                    if Nap=='L':
                        self.X+=1        
                    if Nap=='U':
                        self.Y+=1
                    if Nap=='D':
                        self.Y-=1
                    GGG=GGG+1
                    
            

        #если мы добрались до цели путешествия и это не вход/выход, запускаем функцию погрузки/разгрузки    
        if (self.X==self.pointX) and (self.Y==self.pointY) and ((self.X!=inputX-1) or (self.Y!=inputY)):
            B=False
            if self.mode==1: #если тележка едет за предметом
                if self.IDcargo==0:
                    self.mode=2 #меняем режим на второй
                    B=True
                    self.IDcargo=Mas[self.IDshelf].IDcargo #грузим на тележку предмет с полки
                    if self.IDcargo==0:
                        self.mode=0
                    self.time=Mas[self.IDshelf].time #созраняем время хранения
                    Mas[self.IDshelf].IDcargo=0 #убираем предмет с полки
                    Mas[self.IDshelf].time=0 #обнуляем время хранения на полке
                    self.pointX=Mas[self.IDshelf2].Xpos #записываем в качестве целевой клетки место, куда нужно отвезти предмет 
                    self.pointY=Mas[self.IDshelf2].Ypos
                else: #если тележка полная, но при этом стоит режим загрузки предмета, значит случилась какая-то дичь. Нужно сообщить на всякий случай. При нормальной работе это сообщение не выведется.
                    print('Караул!!! На тележке',self.ID,'предмет',self.IDcargo,'и просят загрузить ещё один -',Mas[self.IDshelf].IDcargo,' с полки',Mas[self.IDshelf].IDshelf)
            if B==False:#это нужно, что бы после установки режима на 2 в прошлом блоке не запускался этот блок
                if self.mode==2: #если тележка привезла предмет и должна его выгрузить.
                    if self.IDcargo!=0: #если тележка не пустая
                        Mas[self.IDshelf2].IDcargo=self.IDcargo #грузим на полку предмет с тележки
                        Mas[self.IDshelf2].time=self.time #записываем на полку время хранения
                        self.mode=0 #меняем режим на нулевой, освобождая тележку
                        self.IDcargo=0 #убираем предмет с тележки
                        self.time=0 #убираем временную метку с тележки
                        self.pointX=self.ID+2 #уводим тележку отсюда
                        self.pointY=0
                    else: #очередное предупреждающее сообщение на случай неверно данных команд
                        print('Караул!!! На тележке',self.ID,' нет предмета, но просят загрузить что-то на полку ',Mas[self.IDshelf].IDshelf)

        if (self.X==self.pointX) and (self.Y==self.pointY) and ((self.X==inputX-1) and (self.Y==inputY)): #если вагонетка добралась до зоны погрузки/разгрузки, осуществляем её
            if self.IDcargo>0:  #если на тележке нет предмета, берём его из пула хранения
                self.mode=2 #меняем режим на второй
                self.IDcargo=Mas[self.IDshelf].IDcargo #грузим на тележку предмет с полки
                self.time=Mas[self.IDshelf].time #созраняем время хранения
                Mas[self.IDshelf].IDcargo=0 #убираем предмет с полки
                Mas[self.IDshelf].time=0 #обнуляем время хранения на полке
                self.pointX=Mas[self.IDshelf2].Xpos #записываем в качестве целевой клетки место, куда нужно отвезти предмет 
                self.pointY=Mas[self.IDshelf2].Ypos
            else: #если на тележке есть предмет, выгружаем его
                if Block==False:
                    self.mode=0
                    self.IDcargo=0 #убираем предмет с тележки
                    self.time=0 #убираем временную метку с тележки
                    self.pointX=self.ID+2   #уводим тележку отсюда
                    self.pointY=0                              


def Start(): #начало работы программы
    global Mas
    global MasRast
    global KolOb
    Mas.append(Slot(inputX,inputY,inputX-1,inputY,0,0)) #нулевая полка. Точка заполнения вагонеток.
    for i in range(LenStorage):
        for r in range(WidthStorage):
            dx=(i*(LenShelving+1))+1 #координаты начала этой полки
            dy=(r*(3))+1
            for g in range(LenShelving):
                for h in range(HeightShelving):
                    KolOb=KolOb+1
                    X=dx+g
                    Y=dy
                    Mas.append(Slot(X,Y,X,Y-1,h,KolOb)) #добавляем верхний ряд ячеек хранения
                    KolOb=KolOb+1
                    Mas.append(Slot(X,Y+1,X,Y+2,h,KolOb))#добавляем нижний ряд ячеек хранения
    for i in range(MaxSizeInput): #добавляем слоты для хранения предметов на входе перед поступлением на склад
        Mas.append(Slot(inputX,inputY,inputX-1,inputY,i,KolOb+i+1)) 
    #создаём массив ячеек хранения, упорядоченый по расстоянию до них
    for i in range(1,KolOb):
        MasRast.append([i,Mas[i].dist])
    for i in range(len(MasRast)):
        for r in range(len(MasRast)-1): #сортировка пузырьком. Не потому, что иначе я не умею, а потому, что этот код выполняется один раз и тут можно наплевать на оптимизацию.
            if MasRast[r][1]>MasRast[r+1][1]:
                GG=MasRast[r]
                MasRast[r]=MasRast[r+1]
                MasRast[r+1]=GG
    

def FindID(ID): #по ID товара возвращает полку, на которой он лежит. Либо -1, если не найдено. 0 - если товар лежит на пункте выдачи.
    for i in range(len(Mas)):
        if Mas[i].IDcargo==ID:
            return(i)
    return(-1)

def FindSlot(X,Y): #если в точке X Y находится полка, возвращает количество товаров на ней. Если нет, возвращает -1.
    global Mas
    k=-1
    for i in range(1,KolOb):
        if (Mas[i].X==X) and (Mas[i].Y==Y):
            if k==-1:
                k=0
            if Mas[i].IDcargo>0:
                k=k+1
    return(k)
    

def RisSclad(): #рисует на экране текущее состояние склада
    global RazKl, MaxX,MaxY
    #отступы от краёв, что бы поле было по центру
    dx=(WindowSizeX-(RazKl*MaxX))//2
    dy=(WindowSizeY-(RazKl*MaxY))//2
    R = pygame.Rect(dx, dy, WindowSizeX-dx*2, WindowSizeY-dy*2)
    pygame.draw.rect(screen, ColFon, R, 0)    #поле склада
  
    for i in range(MaxX): #рисуем отдельные клетки
        for r in range(MaxY):
            X=dx+RazKl*i #координаты текущей клетки в пикселях
            Y=dy+RazKl*r
            R = pygame.Rect(X+1, Y+1, RazKl-2, RazKl-2)
            g=FindSlot(i,r)
            if g==-1: #если полка пустая
                pygame.draw.rect(screen, ColPol, R, 0)
            else: #если на полке есть товары
                pygame.draw.rect(screen, ColStel, R, 0)
                if g>0:
                    #тут нужно выводить в клетку изображение количества товаров
                    pygame.draw.rect(screen, ColTov, R, 0)
               
                    


def RisVagon(): #рисует на экране текущее состояние вагонеток
    global RazKl,MaxX,MaxY
    #отступы от краёв, что бы поле было по центру
    dx=(WindowSizeX-(RazKl*MaxX))//2
    dy=(WindowSizeY-(RazKl*MaxY))//2    
    for i in range(KolVag):
        X=dx+MasV[i].X*RazKl+RazKl//2
        Y=dy+MasV[i].Y*RazKl+RazKl//2
        X1=dx+MasV[i].pointX*RazKl+RazKl//2
        Y1=dy+MasV[i].pointY*RazKl+RazKl//2
        X2=dx+Mas[MasV[i].IDshelf].X*RazKl+RazKl//2
        Y2=dy+Mas[MasV[i].IDshelf].Y*RazKl+RazKl//2
        X3=dx+Mas[MasV[i].IDshelf2].X*RazKl+RazKl//2
        Y3=dy+Mas[MasV[i].IDshelf2].Y*RazKl+RazKl//2
        if MasV[i].IDcargo==0:
            pygame.draw.circle(screen, ColAgent, (X,Y), RazKl//3, 0)    #внутреность вагонетки
        else:
            pygame.draw.circle(screen, ColTov, (X,Y), RazKl//3, 0)    #если есть груз, вагонетка другого цвета
        pygame.draw.circle(screen, Colors[i%(len(Colors))], (X,Y), RazKl//3, 2) #рамка вагонетки. Позволяет их отличать на схеме.
        pygame.draw.circle(screen, Colors[i%(len(Colors))], (X1,Y1), RazKl//6, 2) #целевая клетка вагонетки.
        pygame.draw.circle(screen, Colors[i%(len(Colors))], (X2,Y2), RazKl//6, 2) #целевая полка вагонетки (откуда забрать)
        pygame.draw.circle(screen, Colors[i%(len(Colors))], (X3,Y3), RazKl//6, 1) #целевая полка вагонетки (куда отвезти)


def FindVagon(X,Y): #ищет вагонетку для забирания груза из точки X Y. Если свободной вагонетки нет, возвращает -1. Если есть несколько, возвращает ID той, которая ближе к X Y
    G=-1
    rast=1000000
    for i in range(KolVag):
        if MasV[i].mode==0:
            R=abs(MasV[i].X-X)+abs(MasV[i].Y-Y)
            if R<rast:
                rast=R
                G=i #выбираем ближайшую вагонетку       
    return(G)

def FindVoidPos(Time): #ищет наиболее подходящую полку для хранения предмета.
    #Очевидно, что предмет на долгое хранение нужно отвозить в самый дальний уголок склада. А предметы, которые
    #скоро заберут, нужно хранить поближе к двери. Если предметы со сроком хранения в тысячу лет держать у самой двери,
    #все остальные предметы придётся сдвигать на один слот вглубь склада, что может катострофически снизить скорость доставки.
    #Но вот проблема - какой срок считать большим, какой маленьким? Можно вблизи двери хранить часы. Посередине дни. Вглубине месяц и больше.
    #Но что если все предметы будут храниться часами? Тогда станут важны секунды. Или наоборот все месяцами? Тогда все полки у самой двери
    #будут пустовать, а ведь они самые быстрые. И что если структура склада изменится? На основе этого я решил сделать эмпирическую систему хранения
    #предметов, которая будет адаптироваться под текущий состав склада. Суть проста: в начале мы ничего не знаем о предметах и сроках их
    #хранения, а поэтому помещаем все примерно в центр. А каждый новый предмет помещается относительно предыдущих. Выбирается N ячеек, на их
    #основе определяется, какой срок хранения у нового предмета - долгий или не очень и на основе этого и выбирается его идеальное место на складе.
    #Затем ищется ближайшее к нему свободное, туда предмет и кладётся.
    Min=1 #количество товаров на складе с меньшим сроком хранения
    Max=1 #количество товаров на складе с большим сроком хранения
    for i in range(1,KolOb):
        if Mas[i].IDcargo!=0:
            if Mas[i].time<=Time:
                Min+=1
            else:
                Max+=1
    K=len(MasRast)*(Min/(Min+Max)) #идеальное место что бы воткнуть очередной предмет на склад. Но мы живём не в идеальном мире и это место может быть занято. Так что ищем ближайшее к нему.
    MinID=-1
    MinDist=100000
    for i in range(len(MasRast)):
        if (Mas[MasRast[i][0]].IDcargo==0) and (abs(K-i)<MinDist):
            MinDist=abs(K-i)
            MinID=i
    return(MasRast[MinID][0])

        #добавляет в очередь задание на перемещение предмета с точки выдачи на наилучшую полку
        #как только какая-то тележка освободится, она примет это задание. Если свободных тележек несколько, задание примет ближайшая.
        #Но приоритетными являются задачи по забиранию предметов со склада и выдачи клиентам, так как клиент всегда прав и всё в этом духе.
def DobPredmet(IDcargo,Time): #добавляет в пункт приёма новый предмет, который предстоит хранить time времени. Исходя из этого, ему будет подобрано место на складе и он будет отвезён туда.
    for i in range(KolOb,KolOb+MaxSizeInput): #в первый попавшийся пустой слот добавляем предмет
        if Mas[i].IDcargo==0:
            Mas[i].IDcargo=IDcargo
            Mas[i].time=Time
            break

def ZabratPredmet(IDcargo): #инициирует перемещение предмета со склада на пункт выдачи.
    global Zabir
    Zabir.add(IDcargo) #добавляем новый предмет в очередь



def Update(): #обновляет задания тележкам. Выдаёт имеющися задания свободным.
    Mas[0].time=0 #убираем предметы, выгруженые в зону погрузки тележками
    Mas[0].IDCargo=0
    for i in range(KolVag): #перебираем все вагонетки. Если свободны пытаемся сперва выдать задание - забрать предмет со склада. Если таких нет - положить на склад.
        if MasV[i].mode==0:
            if len(Zabir)>0:
                G=list(Zabir)
                K=G[0] #вагонетка забирает предмет К со склада
                if FindID(K)!=-1: #если предмет есть на складе, отправляем вагонетку его забрать
                    Zabir.discard(K)
                    MasV[i].mode=1
                    MasV[i].IDshelf = FindID(K)
                    MasV[i].IDshelf2 = 0 #пункт выдачи
                    MasV[i].pointX=Mas[MasV[i].IDshelf].Xpos
                    MasV[i].pointY=Mas[MasV[i].IDshelf].Ypos
                    MasV[i].time = 0
                    MasV[i].prior = 1000-MasV[i].ID
            else: #если очередь для забирания со склада пуста, начинаем развозить предметы по складу
                for ii in range(KolOb,KolOb+MaxSizeInput): #ищем на входе предметы для отправки на склад
                    if (Mas[ii].IDcargo>0):
                        Block=True
                        T=FindVoidPos(Mas[ii].time) #выбираем подходящее место для предмета
                        #нужно переместить предмет Mas[ii].IDcargo на полку T.
                        MasV[i].NewPoint(Mas[ii].IDcargo,T)
                        MasV[i].prior = 500-MasV[i].ID
                
                        break
                    
    




Start()
#кладём на склад товары. В данном случае 70 c ID от 1 до 70.
for i in range(180):
    Mas[i].SetID(i+1)
#выпускаем на склад агентов (тележки), в данном случае 3.
for i in range(KolVag):
    MasV.append(Agent(i,0,(i+1)))


for i in range(180):
    ZabratPredmet(i+1)



while True:
    for i in range(KolVag): #каждая вагонетка делает шаг
        MasV[i].drive()
    RisSclad()
    RisVagon()
    time.sleep(0.02)
    pygame.display.flip()
    Update()
   



'''
Алгоритм. Каждая тележка - независимый агент, имеющий целевую клетку, в которую он должен приехать.
На этапе шага поочерёдно все вагонетки пробую приблизиться к своей цели на одну клетку. Если на пути другая вагонетка,
ход пропускается. Если на следующем ходу вагонетка не ушла с пути, с вероятностью 1/2 будет выполнен поиск другого пути,
в котором эта вагонетка считается стеной.

При встрече двух вагонеток есть приоритеты кто кого пропускает. Вагонетка, везущая товары на склад, пропустит вагонетку,
везущую товары на выдачу. Если обе вагонетки везут товар на выдачу, то они везут их в одном направлении и пропускать не
придётся. Пустая вагонетка пропускает полную.

При всех равных проезжает та вагонетка, у которой ID меньше.

Есть список заданий, которые необходимо выполнить. Задания выдаются вагонеткам в порядке поступления.
Если пустых вагонеток несколько, задание берёт та, которая ближе к цели. Если пустых вагонеток нет, задания висят в очереди.

Формат задания - ID исходной полки с товаром. ID конечной полки с товаром. ID товара.
Исходная или конечная полки могут быть равны нулю. Это пункт выдачи-отправки.


'''











